{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Robotic System Integration | Summer Course 2022 Designed and delivered by Eyad Shakab, Arjun Sharma, and Dr. Majid Khonji [July 13 - July 22] This high-level course teaches the basics of system integration using Linux OS and Robot Operating System (ROS). The objective is to build technical maturity and problem-solving skills to deal with diverse software efficiently and in a timely manner to get the task done. The course targets audiences from computer science (CS) backgrounds as well as those from other engineering disciplines as long as they are curious to learn beyond the instructions provided. For CS majors, the course will be more like a revision of basics but at the same time integrates different approaches that the student might not have been exposed to together. Day 1-2: Linux Basics By Eyad Shaklab Tasks: Pre1 : Follow the interactive course by The Construct Pre2 (Optional): Python 3 for Robotics Day 3: Cloud Computing Basics Designed by Majid Khonji, Supervised By Eyad Shaklab Pre-requisites: Basics of Linux OS Fundamentals of computer networks Parts: Sys1 : What is Amazon Web Server (AWS) Sys2 : Setup a clould server using AWS Sys3 : Back-end and front-end development crash course Day 4-7: Robot Operating System By Arjun Sharma ROS1 :Day 4 slides: part 1 | part 2 | part 3 ROS2 :Day 5 slides: part 1 | part 2 ROS3 :Day 6 - 7 (morning) slides: download Day 7-8: Cloud Robotics Designed by Majid Khonji, Supervised by Arjun Sharma The objective here is to learn how to integrate one or more robots with a custom cloud server so that you can achieve some collaborative functionalities. We will try to perform those tasks using standard Linux tools avoiding fancy custom-made software as much as possible. The goal is to build a level of technical maturity at a system level that is generic enough to be applicable across domains. The knowledge you gain in this section will be highly transferrable to other domains outside robotics. It is important to highlight that the tutorial given here is by no mean the most efficient way to develop a production-ready REST API . Day 7 (21/7/2022): Pre-requisites: Basics of networking (ports and ips). If you are not familiar about the topic, watch this 10 min video before you proceed Understanding of HTTP protocol (a simple text based application protocol, running on top of TCP). Here is an 8 min video tutorial Domain Name System (DNS), an application layer protocol. Here is short video tutorial A working installation of Apache web server on your AWS instance from Day 3 Parts: Understanding Web API Sys4 : Fundamentals of Web API: REST Sys5 : Building your first API using Common gateway Interface (CGI) on Apache 2 Sys6 : Debugging REST API on basic level Day 8: Mini-project (22/7/2022) Pre-requisites : Ability to access to a cloud server (AWS, Google, or your Linux box at home with dynamic dns address + port forwarding (80 and 22) ) Fundamentals of REST Parts: Sys7 : More on RESTful Communication Start your mini-project Project: RESTful Robot - A Remote Tracking System Deadline: 29/7/2022 The objective of this exercise is to build a small system that tracks your robots in the cloud. Due to limited time, we will build a simplified system using Turtlebot simulation, but the concept can scale and be applied to any robotic platform. Remember, a robot is simply a computer with sensors and actuators, so you might have a microcontroller (Arduino) connected to a temperature sensor, servo motor, and connected to a PC via a serial connection, USB. That is a legit robot. Increase the number of motors to four, connect a LiDAR and a webcam to the PC, and you get a car capable of autonomous driving. In this project, we have two parts: Cloud server: which collects telemetry information from one or more robots Robot(s): which runs on your laptop. You will write a ROS node that sends POST requests to the server every second to update its location. In this project, you will run a simulated robot, but in principle, the same exact code would run on real robots. More precisely, you should perform the following tasks: Run a Turtlesim simulation. Execute turtlesim_node and turtle_teleop_key (but you may try more sophisticated simulations as well). Remote server connection: Write a ROS node that reads the x and y coordinates of the robot and sends HTTP POST requests to your cloud. Please use three variables in your code to allow easy configuration, robot_name , server_address , and api_delay where api_delay decides how much delay between subsequent API calls; set it to 1 sec. RESTful API: your cloud server should follow the structure below - POST: accept a request following <server_address>/robot_name/x/y , where <robot_name> is the name that you chose in the ROS node, and x and y are Turtle coordinates. You may implement a python code (or bash script or any language you like) that receives the query from CGI module and append the received coordinates to a file named <robot_name>_loc.csv . You can choose any format for the file, but I suggest something like yyyy-mm-dd hh:mm:ss, x, x for each line. - GET: <server_address>/<robot_name> returns a simple HTML that shows a PNG plot for robot location. You may implement it in python and use (https://matplotlib.org/) to output a PNG plot. You may need plt.plot and plt.savefig(<robot_name>.png) Test your code with 2-3 of your colleagues and check if your RESTful API is functional Optional: - Create an additional API that shows all robot locations: a GET API <server_address>/All . - Try to show a live plot using Javascript library . Submission Instruction : Send an Email to eyad.shaklab at ku.ac.ae and arjun.sharma at ku.ac.ae , and CC majid.khonji at ku.ac.ae , titled: - [AV-lab mini-project]: <first_name>_<last_name> In the email, provide the following: - Your <server_address> . Make sure the server will be running for at least 1 week after your submission, if your server is free. if not, then please indicate in the email that the server is off. Our engineer will contact you to switch on the server. - Implemented APIs: indicate which APIs are implemented - Attach your ROS node, named <first_name>_<last_name>.py (if implemented in python) - For computer science folks, you may send your git repo address. For those who are not familiar with git , you may watch this tutorial and decide by yourself. Practical Tips: Running Linux Inside Windows : Problem : Slow performance in a virtual machine or the inconvenience of dual-boot systems. Solution : Use Windows Subsystem for Linux (WSL). It allows you to run Linux commands within Windows OS, offering better performance than a virtual machine. Beginner's Guide to WSL . Text Editor Choices : Basic : Use 'gedit' for a user-friendly graphical interface, ideal for local editing. Advanced : For power users, 'vim' is a highly efficient text editor. It requires a learning curve but significantly enhances productivity. Vim Tutorial for Beginners . Terminal Multiplexer : Issue : Losing SSH connection can terminate all running processes. Solution : Use a terminal multiplexer like 'tmux'. It keeps commands running in the background even after disconnection, allowing you to reattach later. It also enables splitting your terminal into multiple areas. Getting Started with tmux . See also: Video Tutorial . Install with: sudo apt install tmux . Tiling Window Manager for Linux : Overview : Linux's flexible architecture allows extensive customization, including the window manager, which organizes window placements. Recommendation : Try a tiling window manager like 'i3', which automatically arranges windows into tiles, reducing the need for manual adjustment and enhancing productivity. Getting Started with i3 . Watch: Video Tutorial . User-Friendly Shell Alternative : Default : Ubuntu's standard shell is Bash. Alternative : Consider 'fish' (friendly interactive shell), known for its excellent auto-complete feature and useful shortcuts. Note: Not all standard bash commands work out-of-the-box. To load bash configuration files in 'fish', use the 'bass' plugin. Fish Shell Tutorial . More info: Bass Plugin on GitHub .","title":"Home"},{"location":"#robotic-system-integration-summer-course-2022","text":"Designed and delivered by Eyad Shakab, Arjun Sharma, and Dr. Majid Khonji [July 13 - July 22] This high-level course teaches the basics of system integration using Linux OS and Robot Operating System (ROS). The objective is to build technical maturity and problem-solving skills to deal with diverse software efficiently and in a timely manner to get the task done. The course targets audiences from computer science (CS) backgrounds as well as those from other engineering disciplines as long as they are curious to learn beyond the instructions provided. For CS majors, the course will be more like a revision of basics but at the same time integrates different approaches that the student might not have been exposed to together.","title":"Robotic System Integration | Summer Course 2022"},{"location":"#day-1-2-linux-basics","text":"By Eyad Shaklab Tasks: Pre1 : Follow the interactive course by The Construct Pre2 (Optional): Python 3 for Robotics","title":"Day 1-2: Linux Basics"},{"location":"#day-3-cloud-computing-basics","text":"Designed by Majid Khonji, Supervised By Eyad Shaklab Pre-requisites: Basics of Linux OS Fundamentals of computer networks Parts: Sys1 : What is Amazon Web Server (AWS) Sys2 : Setup a clould server using AWS Sys3 : Back-end and front-end development crash course","title":"Day 3: Cloud Computing Basics"},{"location":"#day-4-7-robot-operating-system","text":"By Arjun Sharma ROS1 :Day 4 slides: part 1 | part 2 | part 3 ROS2 :Day 5 slides: part 1 | part 2 ROS3 :Day 6 - 7 (morning) slides: download","title":"Day 4-7: Robot Operating System"},{"location":"#day-7-8-cloud-robotics","text":"Designed by Majid Khonji, Supervised by Arjun Sharma The objective here is to learn how to integrate one or more robots with a custom cloud server so that you can achieve some collaborative functionalities. We will try to perform those tasks using standard Linux tools avoiding fancy custom-made software as much as possible. The goal is to build a level of technical maturity at a system level that is generic enough to be applicable across domains. The knowledge you gain in this section will be highly transferrable to other domains outside robotics. It is important to highlight that the tutorial given here is by no mean the most efficient way to develop a production-ready REST API .","title":"Day 7-8: Cloud Robotics"},{"location":"#day-7-2172022","text":"Pre-requisites: Basics of networking (ports and ips). If you are not familiar about the topic, watch this 10 min video before you proceed Understanding of HTTP protocol (a simple text based application protocol, running on top of TCP). Here is an 8 min video tutorial Domain Name System (DNS), an application layer protocol. Here is short video tutorial A working installation of Apache web server on your AWS instance from Day 3 Parts: Understanding Web API Sys4 : Fundamentals of Web API: REST Sys5 : Building your first API using Common gateway Interface (CGI) on Apache 2 Sys6 : Debugging REST API on basic level","title":"Day 7 (21/7/2022):"},{"location":"#day-8-mini-project-2272022","text":"Pre-requisites : Ability to access to a cloud server (AWS, Google, or your Linux box at home with dynamic dns address + port forwarding (80 and 22) ) Fundamentals of REST Parts: Sys7 : More on RESTful Communication Start your mini-project Project: RESTful Robot - A Remote Tracking System Deadline: 29/7/2022 The objective of this exercise is to build a small system that tracks your robots in the cloud. Due to limited time, we will build a simplified system using Turtlebot simulation, but the concept can scale and be applied to any robotic platform. Remember, a robot is simply a computer with sensors and actuators, so you might have a microcontroller (Arduino) connected to a temperature sensor, servo motor, and connected to a PC via a serial connection, USB. That is a legit robot. Increase the number of motors to four, connect a LiDAR and a webcam to the PC, and you get a car capable of autonomous driving. In this project, we have two parts: Cloud server: which collects telemetry information from one or more robots Robot(s): which runs on your laptop. You will write a ROS node that sends POST requests to the server every second to update its location. In this project, you will run a simulated robot, but in principle, the same exact code would run on real robots. More precisely, you should perform the following tasks: Run a Turtlesim simulation. Execute turtlesim_node and turtle_teleop_key (but you may try more sophisticated simulations as well). Remote server connection: Write a ROS node that reads the x and y coordinates of the robot and sends HTTP POST requests to your cloud. Please use three variables in your code to allow easy configuration, robot_name , server_address , and api_delay where api_delay decides how much delay between subsequent API calls; set it to 1 sec. RESTful API: your cloud server should follow the structure below - POST: accept a request following <server_address>/robot_name/x/y , where <robot_name> is the name that you chose in the ROS node, and x and y are Turtle coordinates. You may implement a python code (or bash script or any language you like) that receives the query from CGI module and append the received coordinates to a file named <robot_name>_loc.csv . You can choose any format for the file, but I suggest something like yyyy-mm-dd hh:mm:ss, x, x for each line. - GET: <server_address>/<robot_name> returns a simple HTML that shows a PNG plot for robot location. You may implement it in python and use (https://matplotlib.org/) to output a PNG plot. You may need plt.plot and plt.savefig(<robot_name>.png) Test your code with 2-3 of your colleagues and check if your RESTful API is functional Optional: - Create an additional API that shows all robot locations: a GET API <server_address>/All . - Try to show a live plot using Javascript library . Submission Instruction : Send an Email to eyad.shaklab at ku.ac.ae and arjun.sharma at ku.ac.ae , and CC majid.khonji at ku.ac.ae , titled: - [AV-lab mini-project]: <first_name>_<last_name> In the email, provide the following: - Your <server_address> . Make sure the server will be running for at least 1 week after your submission, if your server is free. if not, then please indicate in the email that the server is off. Our engineer will contact you to switch on the server. - Implemented APIs: indicate which APIs are implemented - Attach your ROS node, named <first_name>_<last_name>.py (if implemented in python) - For computer science folks, you may send your git repo address. For those who are not familiar with git , you may watch this tutorial and decide by yourself. Practical Tips: Running Linux Inside Windows : Problem : Slow performance in a virtual machine or the inconvenience of dual-boot systems. Solution : Use Windows Subsystem for Linux (WSL). It allows you to run Linux commands within Windows OS, offering better performance than a virtual machine. Beginner's Guide to WSL . Text Editor Choices : Basic : Use 'gedit' for a user-friendly graphical interface, ideal for local editing. Advanced : For power users, 'vim' is a highly efficient text editor. It requires a learning curve but significantly enhances productivity. Vim Tutorial for Beginners . Terminal Multiplexer : Issue : Losing SSH connection can terminate all running processes. Solution : Use a terminal multiplexer like 'tmux'. It keeps commands running in the background even after disconnection, allowing you to reattach later. It also enables splitting your terminal into multiple areas. Getting Started with tmux . See also: Video Tutorial . Install with: sudo apt install tmux . Tiling Window Manager for Linux : Overview : Linux's flexible architecture allows extensive customization, including the window manager, which organizes window placements. Recommendation : Try a tiling window manager like 'i3', which automatically arranges windows into tiles, reducing the need for manual adjustment and enhancing productivity. Getting Started with i3 . Watch: Video Tutorial . User-Friendly Shell Alternative : Default : Ubuntu's standard shell is Bash. Alternative : Consider 'fish' (friendly interactive shell), known for its excellent auto-complete feature and useful shortcuts. Note: Not all standard bash commands work out-of-the-box. To load bash configuration files in 'fish', use the 'bass' plugin. Fish Shell Tutorial . More info: Bass Plugin on GitHub .","title":"Day 8: Mini-project (22/7/2022)"},{"location":"ros/Introduction%20to%20ROS/","text":"Introduction to ROS ROS1 :Day 4 slides: part 1 | part 2 | part 3 ROS2 :Day 5 slides: part 1 | part 2 ROS3 :Day 6 - 7 (morning) slides: download","title":"Introduction to ROS"},{"location":"ros/Introduction%20to%20ROS/#introduction-to-ros","text":"ROS1 :Day 4 slides: part 1 | part 2 | part 3 ROS2 :Day 5 slides: part 1 | part 2 ROS3 :Day 6 - 7 (morning) slides: download","title":"Introduction to ROS"},{"location":"sys/sys1/","text":"What is cloud computing? AWS Amazon Elastic Compute Cloud (Amazon EC2) provides scalable computing capacity in the Amazon Web Services (AWS) Cloud. Using Amazon EC2 eliminates your need to invest in hardware up front, so you can develop and deploy applications faster. You can use Amazon EC2 to launch as many or as few virtual servers as you need, configure security and networking, and manage storage. Amazon EC2 enables you to scale up or down to handle changes in requirements or spikes in popularity, reducing your need to forecast traffic. For more information about cloud computing, see What is cloud computing? Features of Amazon EC2 Amazon EC2 provides the following features: Virtual computing environments, known as instances Preconfigured templates for your instances, known as Amazon Machine Images (AMIs) , that package the bits you need for your server (including the operating system and additional software) Various configurations of CPU, memory, storage, and networking capacity for your instances, known as instance types Secure login information for your instances using key pairs (AWS stores the public key, and you store the private key in a secure place) Storage volumes for temporary data that's deleted when you stop, hibernate, or terminate your instance, known as instance store volumes Persistent storage volumes for your data using Amazon Elastic Block Store (Amazon EBS), known as Amazon EBS volumes Multiple physical locations for your resources, such as instances and Amazon EBS volumes, known as Regions and Availability Zones A firewall that enables you to specify the protocols, ports, and source IP ranges that can reach your instances using security groups Static IPv4 addresses for dynamic cloud computing, known as Elastic IP addresses Metadata, known as tags , that you can create and assign to your Amazon EC2 resources Virtual networks you can create that are logically isolated from the rest of the AWS Cloud, and that you can optionally connect to your own network, known as virtual private clouds (VPCs) For more information about the features of Amazon EC2, see the Amazon EC2 product page . For more information about running your website on AWS, see Web Hosting .","title":"What is cloud computing?"},{"location":"sys/sys1/#what-is-cloud-computing","text":"","title":"What is cloud computing?"},{"location":"sys/sys1/#aws","text":"Amazon Elastic Compute Cloud (Amazon EC2) provides scalable computing capacity in the Amazon Web Services (AWS) Cloud. Using Amazon EC2 eliminates your need to invest in hardware up front, so you can develop and deploy applications faster. You can use Amazon EC2 to launch as many or as few virtual servers as you need, configure security and networking, and manage storage. Amazon EC2 enables you to scale up or down to handle changes in requirements or spikes in popularity, reducing your need to forecast traffic. For more information about cloud computing, see What is cloud computing?","title":"AWS"},{"location":"sys/sys1/#features-of-amazon-ec2","text":"Amazon EC2 provides the following features: Virtual computing environments, known as instances Preconfigured templates for your instances, known as Amazon Machine Images (AMIs) , that package the bits you need for your server (including the operating system and additional software) Various configurations of CPU, memory, storage, and networking capacity for your instances, known as instance types Secure login information for your instances using key pairs (AWS stores the public key, and you store the private key in a secure place) Storage volumes for temporary data that's deleted when you stop, hibernate, or terminate your instance, known as instance store volumes Persistent storage volumes for your data using Amazon Elastic Block Store (Amazon EBS), known as Amazon EBS volumes Multiple physical locations for your resources, such as instances and Amazon EBS volumes, known as Regions and Availability Zones A firewall that enables you to specify the protocols, ports, and source IP ranges that can reach your instances using security groups Static IPv4 addresses for dynamic cloud computing, known as Elastic IP addresses Metadata, known as tags , that you can create and assign to your Amazon EC2 resources Virtual networks you can create that are logically isolated from the rest of the AWS Cloud, and that you can optionally connect to your own network, known as virtual private clouds (VPCs) For more information about the features of Amazon EC2, see the Amazon EC2 product page . For more information about running your website on AWS, see Web Hosting .","title":"Features of Amazon EC2"},{"location":"sys/sys2/","text":"Setup EC2 instances Proceed with the instruction from AWS online documentation Set up Get started tutorial EC2 best practices","title":"Setup AWS"},{"location":"sys/sys2/#setup-ec2-instances","text":"Proceed with the instruction from AWS online documentation Set up Get started tutorial EC2 best practices","title":"Setup EC2 instances"},{"location":"sys/sys3/","text":"Install a web server on the cloud The LAMP stack is a popular open-source solution stack used primarily in web development. LAMP consists of four components necessary to establish a fully functional web development environment. The first letters of the components' names make up the LAMP acronym: Linux is an operating system used to run the rest of the components. Apache HTTP Server is a web server software used to serve static web pages. MySQL is a relational database management system used for creating and managing web databases, but also for data warehousing , application logging, e-commerce, etc. PHP, Perl, and Python are programming languages are used to create web applications. Each component represents an essential layer of the stack. Together, the components are used to create database-driven, dynamic websites. Follow the following instructions from AWS documentation to install a web server on your AWS instance. * Install LAMP on Amazon Linux 2022 Front-end Development To refresh your knowledge on front-end development, you may go through the 4 part crash course: * Part 1 Part 2 Part 3 Part 4 Back-end Development Back-end refers to the server side of web development. In other words, the server can serve multiple clients (or computers). Although HTML/CSS/JS provides a rich user interface, it runs entirely on clients' machines; in other words, it is completely decentralized and agnostic of different clients, which is a limiting factor. What if you want to perform some computation that relies on multiple clients? Say you want to show how many items are available in stock based on online customer records. Then you would need a server that aggregates the computation. LAMP (Linux, Apache, MySQL, PHP) is a software stack that allows running server-side applications using primarily PHP language (and another language), along with MySQL database and Apache server, which orchestrates HTTP communication. In the next classes, we will learn how to develop a simple back-end for your robotic applications. By simple we mean using basic commands and tools in Linux avoiding specialized software and libraries as much as possible. Optional Native Python Server Django and LAMP are technologies for back-end development that involves lots functionalities and performs security checks. If you don't need all these, and you want a simple server for prototype, you may use ptyhon's native http.server library. Below is a short video tutorial. Flask Flask is a small and lightweight Python web framework that provides useful tools and features that make creating web applications in Python easier. It gives developers flexibility and is a more accessible framework for new developers since you can build a web application quickly using only a single Python file. Here is a video tutorial . Flask has it's own lightweight web server, but it is not suitable for production. You can run Apache with Flask by enabling mod_wsgi Django You may try Django framework that allows python for backend development using python * Install Django server on your EC2 instance * Go through Django tutorials PHP PHP is an old technology for back-end development and is tightly integrated with Apache. (I am personally not a big fan of PHP though.). Follow video below Learn PHP in Under 15 Minutes! and run experiments in your AWS server. For more in-depth tutorial, you may follow W3 School tutorial .","title":"Back-end and Front-end Development"},{"location":"sys/sys3/#install-a-web-server-on-the-cloud","text":"The LAMP stack is a popular open-source solution stack used primarily in web development. LAMP consists of four components necessary to establish a fully functional web development environment. The first letters of the components' names make up the LAMP acronym: Linux is an operating system used to run the rest of the components. Apache HTTP Server is a web server software used to serve static web pages. MySQL is a relational database management system used for creating and managing web databases, but also for data warehousing , application logging, e-commerce, etc. PHP, Perl, and Python are programming languages are used to create web applications. Each component represents an essential layer of the stack. Together, the components are used to create database-driven, dynamic websites. Follow the following instructions from AWS documentation to install a web server on your AWS instance. * Install LAMP on Amazon Linux 2022","title":"Install a web server on the cloud"},{"location":"sys/sys3/#front-end-development","text":"To refresh your knowledge on front-end development, you may go through the 4 part crash course: * Part 1 Part 2 Part 3 Part 4","title":"Front-end Development"},{"location":"sys/sys3/#back-end-development","text":"Back-end refers to the server side of web development. In other words, the server can serve multiple clients (or computers). Although HTML/CSS/JS provides a rich user interface, it runs entirely on clients' machines; in other words, it is completely decentralized and agnostic of different clients, which is a limiting factor. What if you want to perform some computation that relies on multiple clients? Say you want to show how many items are available in stock based on online customer records. Then you would need a server that aggregates the computation. LAMP (Linux, Apache, MySQL, PHP) is a software stack that allows running server-side applications using primarily PHP language (and another language), along with MySQL database and Apache server, which orchestrates HTTP communication. In the next classes, we will learn how to develop a simple back-end for your robotic applications. By simple we mean using basic commands and tools in Linux avoiding specialized software and libraries as much as possible.","title":"Back-end Development"},{"location":"sys/sys3/#optional","text":"","title":"Optional"},{"location":"sys/sys3/#native-python-server","text":"Django and LAMP are technologies for back-end development that involves lots functionalities and performs security checks. If you don't need all these, and you want a simple server for prototype, you may use ptyhon's native http.server library. Below is a short video tutorial.","title":"Native Python Server"},{"location":"sys/sys3/#flask","text":"Flask is a small and lightweight Python web framework that provides useful tools and features that make creating web applications in Python easier. It gives developers flexibility and is a more accessible framework for new developers since you can build a web application quickly using only a single Python file. Here is a video tutorial . Flask has it's own lightweight web server, but it is not suitable for production. You can run Apache with Flask by enabling mod_wsgi","title":"Flask"},{"location":"sys/sys3/#django","text":"You may try Django framework that allows python for backend development using python * Install Django server on your EC2 instance * Go through Django tutorials","title":"Django"},{"location":"sys/sys3/#php","text":"PHP is an old technology for back-end development and is tightly integrated with Apache. (I am personally not a big fan of PHP though.). Follow video below Learn PHP in Under 15 Minutes! and run experiments in your AWS server. For more in-depth tutorial, you may follow W3 School tutorial .","title":"PHP"},{"location":"sys/sys4/","text":"REST API Basics Overview A REST API (also known as RESTful API) is an application programming interface (API or web API) that conforms to the constraints of REST architectural style and allows for interaction with RESTful web services. REST stands for representational state transfer and was created by computer scientist Roy Fielding. What's an API*? An API is a set of definitions and protocols for building and integrating application software. It\u2019s sometimes referred to as a contract between an information provider and an information user\u2014establishing the content required from the consumer (the call) and the content required by the producer (the response). For example, the API design for a weather service could specify that the user supply a zip code and that the producer reply with a 2-part answer, the first being the high temperature, and the second being the low. In other words, if you want to interact with a computer or system to retrieve information or perform a function, an API helps you communicate what you want to that system so it can understand and fulfill the request. You can think of an API as a mediator between the users or clients and the resources or web services they want to get. It\u2019s also a way for an organization to share resources and information while maintaining security, control, and authentication\u2014determining who gets access to what. Another advantage of an API is that you don\u2019t have to know the specifics of caching\u2014how your resource is retrieved or where it comes from. REST REST is a set of architectural constraints, not a protocol or a standard. API developers can implement REST in a variety of ways. When a client request is made via a RESTful API, it transfers a representation of the state of the resource to the requester or endpoint. This information, or representation, is delivered in one of several formats via HTTP: JSON (Javascript Object Notation), HTML, XLT, Python, PHP, or plain text. JSON is the most generally popular file format to use because, despite its name, it\u2019s language-agnostic, as well as readable by both humans and machines. Something else to keep in mind: Headers and parameters are also important in the HTTP methods of a RESTful API HTTP request, as they contain important identifier information as to the request's metadata, authorization, uniform resource identifier (URI), caching, cookies, and more. There are request headers and response headers, each with their own HTTP connection information and status codes. In order for an API to be considered RESTful, it has to conform to these criteria: A client-server architecture made up of clients, servers, and resources, with requests managed through HTTP. Stateless client-server communication, meaning no client information is stored between get requests and each request is separate and unconnected. Cacheable data that streamlines client-server interactions. A uniform interface between components so that information is transferred in a standard form. This requires that: * resources requested are identifiable and separate from the representations sent to the client. * resources can be manipulated by the client via the representation they receive because the representation contains enough information to do so. * self-descriptive messages returned to the client have enough information to describe how the client should process it. * hypertext/hypermedia is available, meaning that after accessing a resource the client should be able to use hyperlinks to find all other currently available actions they can take. A layered system that organizes each type of server (those responsible for security, load-balancing, etc.) involved the retrieval of requested information into hierarchies, invisible to the client. Code-on-demand (optional): the ability to send executable code from the server to the client when requested, extending client functionality. Though the REST API has these criteria to conform to, it is still considered easier to use than a prescribed protocol like SOAP (Simple Object Access Protocol), which has specific requirements like XML messaging, and built-in security and transaction compliance that make it slower and heavier. In contrast, REST is a set of guidelines that can be implemented as needed, making REST APIs faster and more lightweight, with increased scalablity\u2014perfect for Internet of Things (IoT) and mobile app development . * Material taken form Redhat.com Using HTTP Methods for RESTful Services The HTTP verbs comprise a major portion of our \u201cuniform interface\u201d constraint and provide us the action counterpart to the noun-based resource. The primary or most-commonly-used HTTP verbs (or methods, as they are properly called) are POST, GET, PUT, PATCH, and DELETE. These correspond to create, read, update, and delete (or CRUD) operations, respectively. There are a number of other verbs, too, but are utilized less frequently. Of those less-frequent methods, OPTIONS and HEAD are used more often than others. Below is a table summarizing recommended return values of the primary HTTP methods in combination with the resource URIs HTTP Verb CRUD Entire Collection (e.g. /customers) Specific Item (e.g. /customers/{id}) POST Create 201 (Created), 'Location' header with link to /customers/{id} containing new ID. 404 (Not Found), 409 (Conflict) if resource already exists.. GET Read 200 (OK), list of customers. Use pagination, sorting and filtering to navigate big lists. 200 (OK), single customer. 404 (Not Found), if ID not found or invalid. PUT Update/Replace 405 (Method Not Allowed), unless you want to update/replace every resource in the entire collection. 200 (OK) or 204 (No Content). 404 (Not Found), if ID not found or invalid. PATCH Update/Modify 405 (Method Not Allowed), unless you want to modify the collection itself. 200 (OK) or 204 (No Content). 404 (Not Found), if ID not found or invalid. DELETE Delete 405 (Method Not Allowed), unless you want to delete the whole collection\u2014not often desirable. 200 (OK). 404 (Not Found), if ID not found or invalid. GET The HTTP GET method is used to **read** (or retrieve) a representation of a resource. In the \u201chappy\u201d (or non-error) path, GET returns a representation in XML or JSON and an HTTP response code of 200 (OK). In an error case, it most often returns a 404 (NOT FOUND) or 400 (BAD REQUEST). According to the design of the HTTP specification, GET (along with HEAD) requests are used only to read data and not change it. Therefore, when used this way, they are considered safe. That is, they can be called without risk of data modification or corruption\u2014calling it once has the same effect as calling it 10 times, or none at all. Additionally, GET (and HEAD) is idempotent, which means that making multiple identical requests ends up having the same result as a single request. Do not expose unsafe operations via GET\u2014it should never modify any resources on the server. Examples: GET http://www.example.com/customers/12345 GET http://www.example.com/customers/12345/orders GET http://www.example.com/buckets/sample POST The POST verb is most-often utilized to **create** new resources. In particular, it's used to create subordinate resources. That is, subordinate to some other (e.g. parent) resource. In other words, when creating a new resource, POST to the parent and the service takes care of associating the new resource with the parent, assigning an ID (new resource URI), etc. On successful creation, return HTTP status 201, returning a Location header with a link to the newly-created resource with the 201 HTTP status. POST is neither safe nor idempotent. It is therefore recommended for non-idempotent resource requests. Making two identical POST requests will most-likely result in two resources containing the same information. Examples: POST http://www.example.com/customers POST http://www.example.com/customers/12345/orders DELETE DELETE is pretty easy to understand. It is used to **delete** a resource identified by a URI. On successful deletion, return HTTP status 200 (OK) along with a response body, perhaps the representation of the deleted item (often demands too much bandwidth), or a wrapped response (see Return Values below). Either that or return HTTP status 204 (NO CONTENT) with no response body. In other words, a 204 status with no body, or the JSEND-style response and HTTP status 200 are the recommended responses. HTTP-spec-wise, DELETE operations are idempotent. If you DELETE a resource, it's removed. Repeatedly calling DELETE on that resource ends up the same: the resource is gone. If calling DELETE say, decrements a counter (within the resource), the DELETE call is no longer idempotent. As mentioned previously, usage statistics and measurements may be updated while still considering the service idempotent as long as no resource data is changed. Using POST for non-idempotent resource requests is recommended. There is a caveat about DELETE idempotence, however. Calling DELETE on a resource a second time will often return a 404 (NOT FOUND) since it was already removed and therefore is no longer findable. This, by some opinions, makes DELETE operations no longer idempotent, however, the end-state of the resource is the same. Returning a 404 is acceptable and communicates accurately the status of the call. Examples: DELETE http://www.example.com/customers/12345 DELETE http://www.example.com/customers/12345/orders DELETE http://www.example.com/bucket/sample","title":"REST API Basics"},{"location":"sys/sys4/#rest-api-basics","text":"","title":"REST API Basics"},{"location":"sys/sys4/#overview","text":"A REST API (also known as RESTful API) is an application programming interface (API or web API) that conforms to the constraints of REST architectural style and allows for interaction with RESTful web services. REST stands for representational state transfer and was created by computer scientist Roy Fielding.","title":"Overview"},{"location":"sys/sys4/#whats-an-api","text":"An API is a set of definitions and protocols for building and integrating application software. It\u2019s sometimes referred to as a contract between an information provider and an information user\u2014establishing the content required from the consumer (the call) and the content required by the producer (the response). For example, the API design for a weather service could specify that the user supply a zip code and that the producer reply with a 2-part answer, the first being the high temperature, and the second being the low. In other words, if you want to interact with a computer or system to retrieve information or perform a function, an API helps you communicate what you want to that system so it can understand and fulfill the request. You can think of an API as a mediator between the users or clients and the resources or web services they want to get. It\u2019s also a way for an organization to share resources and information while maintaining security, control, and authentication\u2014determining who gets access to what. Another advantage of an API is that you don\u2019t have to know the specifics of caching\u2014how your resource is retrieved or where it comes from.","title":"What's an API*?"},{"location":"sys/sys4/#rest","text":"REST is a set of architectural constraints, not a protocol or a standard. API developers can implement REST in a variety of ways. When a client request is made via a RESTful API, it transfers a representation of the state of the resource to the requester or endpoint. This information, or representation, is delivered in one of several formats via HTTP: JSON (Javascript Object Notation), HTML, XLT, Python, PHP, or plain text. JSON is the most generally popular file format to use because, despite its name, it\u2019s language-agnostic, as well as readable by both humans and machines. Something else to keep in mind: Headers and parameters are also important in the HTTP methods of a RESTful API HTTP request, as they contain important identifier information as to the request's metadata, authorization, uniform resource identifier (URI), caching, cookies, and more. There are request headers and response headers, each with their own HTTP connection information and status codes. In order for an API to be considered RESTful, it has to conform to these criteria: A client-server architecture made up of clients, servers, and resources, with requests managed through HTTP. Stateless client-server communication, meaning no client information is stored between get requests and each request is separate and unconnected. Cacheable data that streamlines client-server interactions. A uniform interface between components so that information is transferred in a standard form. This requires that: * resources requested are identifiable and separate from the representations sent to the client. * resources can be manipulated by the client via the representation they receive because the representation contains enough information to do so. * self-descriptive messages returned to the client have enough information to describe how the client should process it. * hypertext/hypermedia is available, meaning that after accessing a resource the client should be able to use hyperlinks to find all other currently available actions they can take. A layered system that organizes each type of server (those responsible for security, load-balancing, etc.) involved the retrieval of requested information into hierarchies, invisible to the client. Code-on-demand (optional): the ability to send executable code from the server to the client when requested, extending client functionality. Though the REST API has these criteria to conform to, it is still considered easier to use than a prescribed protocol like SOAP (Simple Object Access Protocol), which has specific requirements like XML messaging, and built-in security and transaction compliance that make it slower and heavier. In contrast, REST is a set of guidelines that can be implemented as needed, making REST APIs faster and more lightweight, with increased scalablity\u2014perfect for Internet of Things (IoT) and mobile app development . * Material taken form Redhat.com","title":"REST"},{"location":"sys/sys4/#using-http-methods-for-restful-services","text":"The HTTP verbs comprise a major portion of our \u201cuniform interface\u201d constraint and provide us the action counterpart to the noun-based resource. The primary or most-commonly-used HTTP verbs (or methods, as they are properly called) are POST, GET, PUT, PATCH, and DELETE. These correspond to create, read, update, and delete (or CRUD) operations, respectively. There are a number of other verbs, too, but are utilized less frequently. Of those less-frequent methods, OPTIONS and HEAD are used more often than others. Below is a table summarizing recommended return values of the primary HTTP methods in combination with the resource URIs HTTP Verb CRUD Entire Collection (e.g. /customers) Specific Item (e.g. /customers/{id}) POST Create 201 (Created), 'Location' header with link to /customers/{id} containing new ID. 404 (Not Found), 409 (Conflict) if resource already exists.. GET Read 200 (OK), list of customers. Use pagination, sorting and filtering to navigate big lists. 200 (OK), single customer. 404 (Not Found), if ID not found or invalid. PUT Update/Replace 405 (Method Not Allowed), unless you want to update/replace every resource in the entire collection. 200 (OK) or 204 (No Content). 404 (Not Found), if ID not found or invalid. PATCH Update/Modify 405 (Method Not Allowed), unless you want to modify the collection itself. 200 (OK) or 204 (No Content). 404 (Not Found), if ID not found or invalid. DELETE Delete 405 (Method Not Allowed), unless you want to delete the whole collection\u2014not often desirable. 200 (OK). 404 (Not Found), if ID not found or invalid.","title":"Using HTTP Methods for RESTful Services"},{"location":"sys/sys4/#get","text":"The HTTP GET method is used to **read** (or retrieve) a representation of a resource. In the \u201chappy\u201d (or non-error) path, GET returns a representation in XML or JSON and an HTTP response code of 200 (OK). In an error case, it most often returns a 404 (NOT FOUND) or 400 (BAD REQUEST). According to the design of the HTTP specification, GET (along with HEAD) requests are used only to read data and not change it. Therefore, when used this way, they are considered safe. That is, they can be called without risk of data modification or corruption\u2014calling it once has the same effect as calling it 10 times, or none at all. Additionally, GET (and HEAD) is idempotent, which means that making multiple identical requests ends up having the same result as a single request. Do not expose unsafe operations via GET\u2014it should never modify any resources on the server. Examples: GET http://www.example.com/customers/12345 GET http://www.example.com/customers/12345/orders GET http://www.example.com/buckets/sample","title":"GET"},{"location":"sys/sys4/#post","text":"The POST verb is most-often utilized to **create** new resources. In particular, it's used to create subordinate resources. That is, subordinate to some other (e.g. parent) resource. In other words, when creating a new resource, POST to the parent and the service takes care of associating the new resource with the parent, assigning an ID (new resource URI), etc. On successful creation, return HTTP status 201, returning a Location header with a link to the newly-created resource with the 201 HTTP status. POST is neither safe nor idempotent. It is therefore recommended for non-idempotent resource requests. Making two identical POST requests will most-likely result in two resources containing the same information. Examples: POST http://www.example.com/customers POST http://www.example.com/customers/12345/orders","title":"POST"},{"location":"sys/sys4/#delete","text":"DELETE is pretty easy to understand. It is used to **delete** a resource identified by a URI. On successful deletion, return HTTP status 200 (OK) along with a response body, perhaps the representation of the deleted item (often demands too much bandwidth), or a wrapped response (see Return Values below). Either that or return HTTP status 204 (NO CONTENT) with no response body. In other words, a 204 status with no body, or the JSEND-style response and HTTP status 200 are the recommended responses. HTTP-spec-wise, DELETE operations are idempotent. If you DELETE a resource, it's removed. Repeatedly calling DELETE on that resource ends up the same: the resource is gone. If calling DELETE say, decrements a counter (within the resource), the DELETE call is no longer idempotent. As mentioned previously, usage statistics and measurements may be updated while still considering the service idempotent as long as no resource data is changed. Using POST for non-idempotent resource requests is recommended. There is a caveat about DELETE idempotence, however. Calling DELETE on a resource a second time will often return a 404 (NOT FOUND) since it was already removed and therefore is no longer findable. This, by some opinions, makes DELETE operations no longer idempotent, however, the end-state of the resource is the same. Returning a 404 is acceptable and communicates accurately the status of the call. Examples: DELETE http://www.example.com/customers/12345 DELETE http://www.example.com/customers/12345/orders DELETE http://www.example.com/bucket/sample","title":"DELETE"},{"location":"sys/sys5/","text":"Basics In computing, Common Gateway Interface (CGI) is an interface specification that enables web servers to execute an external program, typically to process user requests. Such programs are often written in a scripting language and are commonly referred to as CGI scripts, but they may include compiled programs. A typical use case occurs when a web user submits a web form on a web page that uses CGI. The form's data is sent to the web server within an HTTP request with a URL denoting a CGI script. The web server then launches the CGI script in a new computer process, passing the form data to it. The output of the CGI script, usually in the form of HTML, is returned by the script to the Web server, and the server relays it back to the browser as its response to the browser's request. Read more (Wikipedia) . Configuring Apache2 for CGI The instructions below are given for ubuntu 22.04 instance. There might be small differences between Linux distributions, particularly with directory names. First, make sure that Apache 2 is installed. In this tutorial, our website is hosted under /var/www/html/ . Verify that the server is running in the background: run systemctl status apache2 ; make sure it shows running . In some Linux distributions, the server name could be httpd instead of apache2 Make sure your AWS instance listens to port 80 (update your inboud security rules) Create a directory under your root website called cgi sudo mkdir /<root directory>/cgi where <root directory> should be replaced by your website root directory. You can find your website root written somewhere in the apache config under DocumentRoot /var/www/html * Give the directory 755 permission (read and execute for user and group) using chmod command with root (or sudo). Recall that execute permission for a directory means the ability to access the directory and see files. * Open apache configuration with your favorite text editor (gedit, nano, vim,...etc). In Ubuntu, the main config file is /etc/apache2/apache2.conf . (The config is written in XML format, which is self-explanatory to a certain level; you may check the official documentation to have more insights) * Once you open the file, you will notice that the config envokes all files under two directories, conf-enabled/ and sites-enabled/ . Each of those files contains some segments of XML configs. * You may pick /etc/apache2/sites-available/000-default.conf if it corresponds to your default website. Edit the file and include the configs below ```xml <Directory /var/www/html/cgi> AllowOverride None Options +ExecCGI AddHandler cgi-script .cgi .py .sh Require all granted </Directory> ``` It basically says that all files that have extensions `.cgi, .py, .sh` under the CGI directory `/var/www/html/cgi/` should be executable. Enable CGI module in Apache cd /etc/apache2/mods-enabled sudo ln -s ../mods-available/cgi.load where in Ubuntu 22.04 (installed by apt package manager), all modules are listed under /etc/apache2/mods-available/ . The second command simply creates a symlink (or shortcut) for cgi.load inside mods-enabled to indicate that CGI module needs to be loaded along with other apache modules * Restart Apache through Systemd 's utility systemctl restart apache2 Creating your first CGI script Navigate to your CGI directory Create a file named test.cgi sudo touch test.sh Change the permission of the file to be executable sudo chmod +x test.sh Write a simple bash script that prints some HTML using echo command ```bash #!/usr/bin/bash echo -e \"Content-type: text/html\\n\\n\" echo \" Hello world! this is NSR 4.0 \" echo \" My name is XXX \" `` where the first line tells the OS which scripting language to use. The last two lines are simple HTML code, and the Content-type`is a part of the http header (notice the two empty lines and option -e for command echo). Go to your browser, and check your cgi script (replace the DNS with your own domain address). The output should be similar to the figure below (not some script source) Simple RESTful API The main idea is to learn how to redirect URL addresses to certain files. We start first with a simple REST API using a module called rewrite . Enable module simply by navigating to mode_enabled directory and creating a sym link. sudo ln -s ../mods-available/rewrite.load Restart Apache to ensure that the module is loaded Open apache config file that corresponds to the root site. Locate the <Directory>...</Directory> directive, which includes the settings. In Ubuntu 22.04 instance, it looks like ```xml Options Indexes FollowSymLinks AllowOverride None Require all granted Make sure `AllowOverride None` is set to `AllowOverride All` * Restart Apache server (whenever you edit any apache config file, you must restart apache to enforce the changes) * Enable mod rewrite in the config adding the following inside directive ` <Directory /var/www/html>` RewriteEngine On * Add to the above directive `<Directory /var/www/html>` a simple rule RewriteRule X cgi/test.sh The rule simply says the URL ending with X, will be redirected to CGI/test.sh. Basically, the link `http://<your-dns-address>/X` will lead to your `test.sh` script * All `RewriteRules` abide by the following format: RewriteRule pattern substitution [flags] where * `RewriteRule` specifies the directive. * `pattern` is a [regular expression (Regex)](https://www.digitalocean.com/community/tutorials/an-introduction-to-regular-expressions) that matches the desired string from the URL, which is what the viewer types in the browser. * `substitution` is the path to the actual URL, i.e. the path of the file Apache servers. * `flags` are optional parameters that can modify how the rule works. * If you add special flag `[NC]` to `RewriteRule X cgi/test.s [NC]`, then it becomes case insensitive, so both `x` and `X` lead to the same executable. * Let's write a more generic rewrite rule using variables. A variable is enclosed in parenthesis `()`, following the Regex standard. RewriteRule select/(a|b) cgi/test.sh?option=$1 For example, the above rule redirects `<url>/select/a` and `<url>/select/b` to `/cgi/test.sh` where `$1` takes values `a` and `b` for variable `option`. If you are not comfortable with Regex, you could write the above as two static rules RewriteRule select/a cgi/test.sh?option=a RewriteRule select/b cgi/test.sh?option=b `` * Now, from the bash script test.sh you could read the input through the environment variable $QUERY_STRING`, which is set automatically by mod_rewrite. * Try to write a simple bash script that outputs the figure below Optional Additional mod_rewrite tutorial Regex tutorial Full documentation for mod_rewrite","title":"Simple API using CGI Module"},{"location":"sys/sys5/#basics","text":"In computing, Common Gateway Interface (CGI) is an interface specification that enables web servers to execute an external program, typically to process user requests. Such programs are often written in a scripting language and are commonly referred to as CGI scripts, but they may include compiled programs. A typical use case occurs when a web user submits a web form on a web page that uses CGI. The form's data is sent to the web server within an HTTP request with a URL denoting a CGI script. The web server then launches the CGI script in a new computer process, passing the form data to it. The output of the CGI script, usually in the form of HTML, is returned by the script to the Web server, and the server relays it back to the browser as its response to the browser's request. Read more (Wikipedia) .","title":"Basics"},{"location":"sys/sys5/#configuring-apache2-for-cgi","text":"The instructions below are given for ubuntu 22.04 instance. There might be small differences between Linux distributions, particularly with directory names. First, make sure that Apache 2 is installed. In this tutorial, our website is hosted under /var/www/html/ . Verify that the server is running in the background: run systemctl status apache2 ; make sure it shows running . In some Linux distributions, the server name could be httpd instead of apache2 Make sure your AWS instance listens to port 80 (update your inboud security rules) Create a directory under your root website called cgi sudo mkdir /<root directory>/cgi where <root directory> should be replaced by your website root directory. You can find your website root written somewhere in the apache config under DocumentRoot /var/www/html * Give the directory 755 permission (read and execute for user and group) using chmod command with root (or sudo). Recall that execute permission for a directory means the ability to access the directory and see files. * Open apache configuration with your favorite text editor (gedit, nano, vim,...etc). In Ubuntu, the main config file is /etc/apache2/apache2.conf . (The config is written in XML format, which is self-explanatory to a certain level; you may check the official documentation to have more insights) * Once you open the file, you will notice that the config envokes all files under two directories, conf-enabled/ and sites-enabled/ . Each of those files contains some segments of XML configs. * You may pick /etc/apache2/sites-available/000-default.conf if it corresponds to your default website. Edit the file and include the configs below ```xml <Directory /var/www/html/cgi> AllowOverride None Options +ExecCGI AddHandler cgi-script .cgi .py .sh Require all granted </Directory> ``` It basically says that all files that have extensions `.cgi, .py, .sh` under the CGI directory `/var/www/html/cgi/` should be executable. Enable CGI module in Apache cd /etc/apache2/mods-enabled sudo ln -s ../mods-available/cgi.load where in Ubuntu 22.04 (installed by apt package manager), all modules are listed under /etc/apache2/mods-available/ . The second command simply creates a symlink (or shortcut) for cgi.load inside mods-enabled to indicate that CGI module needs to be loaded along with other apache modules * Restart Apache through Systemd 's utility systemctl restart apache2","title":"Configuring Apache2 for CGI"},{"location":"sys/sys5/#creating-your-first-cgi-script","text":"Navigate to your CGI directory Create a file named test.cgi sudo touch test.sh Change the permission of the file to be executable sudo chmod +x test.sh Write a simple bash script that prints some HTML using echo command ```bash #!/usr/bin/bash echo -e \"Content-type: text/html\\n\\n\" echo \"","title":"Creating your first CGI script"},{"location":"sys/sys5/#simple-restful-api","text":"The main idea is to learn how to redirect URL addresses to certain files. We start first with a simple REST API using a module called rewrite . Enable module simply by navigating to mode_enabled directory and creating a sym link. sudo ln -s ../mods-available/rewrite.load Restart Apache to ensure that the module is loaded Open apache config file that corresponds to the root site. Locate the <Directory>...</Directory> directive, which includes the settings. In Ubuntu 22.04 instance, it looks like ```xml Options Indexes FollowSymLinks AllowOverride None Require all granted Make sure `AllowOverride None` is set to `AllowOverride All` * Restart Apache server (whenever you edit any apache config file, you must restart apache to enforce the changes) * Enable mod rewrite in the config adding the following inside directive ` <Directory /var/www/html>` RewriteEngine On * Add to the above directive `<Directory /var/www/html>` a simple rule RewriteRule X cgi/test.sh The rule simply says the URL ending with X, will be redirected to CGI/test.sh. Basically, the link `http://<your-dns-address>/X` will lead to your `test.sh` script * All `RewriteRules` abide by the following format: RewriteRule pattern substitution [flags] where * `RewriteRule` specifies the directive. * `pattern` is a [regular expression (Regex)](https://www.digitalocean.com/community/tutorials/an-introduction-to-regular-expressions) that matches the desired string from the URL, which is what the viewer types in the browser. * `substitution` is the path to the actual URL, i.e. the path of the file Apache servers. * `flags` are optional parameters that can modify how the rule works. * If you add special flag `[NC]` to `RewriteRule X cgi/test.s [NC]`, then it becomes case insensitive, so both `x` and `X` lead to the same executable. * Let's write a more generic rewrite rule using variables. A variable is enclosed in parenthesis `()`, following the Regex standard. RewriteRule select/(a|b) cgi/test.sh?option=$1 For example, the above rule redirects `<url>/select/a` and `<url>/select/b` to `/cgi/test.sh` where `$1` takes values `a` and `b` for variable `option`. If you are not comfortable with Regex, you could write the above as two static rules RewriteRule select/a cgi/test.sh?option=a RewriteRule select/b cgi/test.sh?option=b `` * Now, from the bash script test.sh you could read the input through the environment variable $QUERY_STRING`, which is set automatically by mod_rewrite. * Try to write a simple bash script that outputs the figure below","title":"Simple RESTful API"},{"location":"sys/sys5/#optional","text":"Additional mod_rewrite tutorial Regex tutorial Full documentation for mod_rewrite","title":"Optional"},{"location":"sys/sys6/","text":"Debugging REST API with Command Line Overview nc command Netcat is a utility that reads and writes data across network connections, using the TCP or UDP protocols . It is designed to be a reliable \"back-end\" tool, used directly or driven by other programs and scripts . At the same time, it is a feature-rich network debugging and exploration tool since it can create almost any kind of connection you would need and has several interesting built-in capabilities. Common uses include: Simple TCP proxies Shell -script based HTTP clients and servers Network daemon testing A SOCKS or HTTP ProxyCommand for ssh Run man nc to have an overview. Create Chat Server Interestingly the nc command can be used to create chat server where multiple users can connect and send messages. The methodology used to create chat server is the same with file transfer. In this case simple text is transferred between local and remote systems. * First we will create a listening port which will be 4444 in this case. nc -l 4444 On the another terminal (on the same computer or another computer) we will connect to the chat server by providing its IP address and port number which is 4444. nc <ip address> 4444 where <ip address> is replaced by your local ip 127.0.0.1 if running the command on the same machine as the server, or replaced by the server ip. You will get something similar to the picture below: Make HTTP Request The nc command can be used to make HTTP Requests to the remote web server. Even there are more useful tools nc provides basic usage about making HTTP Requests. The HTTP Request text is redirected into the nc command where the nc command uses the specified remote web server IP address/Hostname and port number. printf \"GET / HTTP/1.1\" | nc google.com 80 Notice the pipe | commands shifts the output of the comands on left hand side to the input of the right hand side. Alternatively the multiple lines for the HTTP Request can be expressed by using the \u201c\\r\\n\u201d end of line. printf \"GET / HTTP/1.1\\r\\nHost:google.com\\r\\n\\r\\n\" | nc google.com 80","title":"Debugging REST API with Command Line"},{"location":"sys/sys6/#debugging-rest-api-with-command-line","text":"","title":"Debugging REST API with Command Line"},{"location":"sys/sys6/#overview-nc-command","text":"Netcat is a utility that reads and writes data across network connections, using the TCP or UDP protocols . It is designed to be a reliable \"back-end\" tool, used directly or driven by other programs and scripts . At the same time, it is a feature-rich network debugging and exploration tool since it can create almost any kind of connection you would need and has several interesting built-in capabilities. Common uses include: Simple TCP proxies Shell -script based HTTP clients and servers Network daemon testing A SOCKS or HTTP ProxyCommand for ssh Run man nc to have an overview.","title":"Overview nc command"},{"location":"sys/sys6/#create-chat-server","text":"Interestingly the nc command can be used to create chat server where multiple users can connect and send messages. The methodology used to create chat server is the same with file transfer. In this case simple text is transferred between local and remote systems. * First we will create a listening port which will be 4444 in this case. nc -l 4444 On the another terminal (on the same computer or another computer) we will connect to the chat server by providing its IP address and port number which is 4444. nc <ip address> 4444 where <ip address> is replaced by your local ip 127.0.0.1 if running the command on the same machine as the server, or replaced by the server ip. You will get something similar to the picture below:","title":"Create Chat Server"},{"location":"sys/sys6/#make-http-request","text":"The nc command can be used to make HTTP Requests to the remote web server. Even there are more useful tools nc provides basic usage about making HTTP Requests. The HTTP Request text is redirected into the nc command where the nc command uses the specified remote web server IP address/Hostname and port number. printf \"GET / HTTP/1.1\" | nc google.com 80 Notice the pipe | commands shifts the output of the comands on left hand side to the input of the right hand side. Alternatively the multiple lines for the HTTP Request can be expressed by using the \u201c\\r\\n\u201d end of line. printf \"GET / HTTP/1.1\\r\\nHost:google.com\\r\\n\\r\\n\" | nc google.com 80","title":"Make HTTP Request"},{"location":"sys/sys7/","text":"More on RESTful Communication REST APIs use Uniform Resource Identifiers (URIs) to address resources . REST API designers should create URIs that convey a REST API's resource model to the potential clients of the API. When resources are named well, an API is intuitive and easy to use. Mod Rewrite with POST requests To partition API to POST and GET APIs, you need to modify Apache config to include some conditions. * Open your Apache config file, mine is located in /etc/apache2/sites-available/000-default.conf , and add the following with root permission RewriteCond %{REQUEST_METHOD} ^POST$ [NC] RewriteRule robot cgi/test.sh The condition specifies how to redirect the address based on the request type. Check Apache site for more details about RewriteCond . * Restart your Apache server * To test POST requests, you cannot use your browser easily because the browser operates mainly on GET part of HTTP (unless you create a custom HTML form to submit data). Try curl command ( sudo apt install curl if you don't have it on your system) curl -X POST '<address>/robot' Check if you receive correct HTML response. You can use the same command for GET requests (replacing POST by GET). curl is quite simpler than nc as you don't need to specify HTTP headers. However, it is good to experience low-level interactions, particularly with HTTP protocol, a text-based protocol intended by design to help humans debug easily without sophisticated parsing tools. Variables Now, let's use the regex to have a POST URI that takes any number. Replace the RewriteRule by the following: RewriteRule ^robot/([0-9]*\\.?[0-9]*$) cgi/test.sh?data=$1 Let's parse it now: * ^ indicates the beginning of URI, where $ marks the end. So robot/ should be the first sequence of letters. () means a group of letters and is also used as a placeholder for variables in mod_rewrite . [0-9] means any number from 0 to 9, * means the previous character type (or block) is repeated once or multiple times. + means it is repeated 0 or many times. \\ is a skip letter for special characters like . . ? says the previous char or block occurs zero or exactly one time. * Now, test the URI with a POST request curl -X POST '<address>/robot/123.23' The output should be <h1>Hello world from NSR 4.0!</h1> <h2>My name is XXX </h2> <h2> data=123.23 is selected</h2> Try different addresses and see if the regex rule works as intended curl -X POST '<address>/robot/123.23' curl -X POST '<address>/robot/532' curl -X POST '<address>/robot/12a3.23' # Error 404 Not found Web communication in Python - Client side It is quite easy to make HTTP requests in python using libraries like requests . Below is an example code. * Lets make a simple GET request to your previously designed API. Create a file, named req.py (or run interatively using ipython or Jupiter notebook ) import requests url = '<ur server dns>/select/b' x = requests.get(url) print(x.text) If you run print(x) you will get HTTP response status code, which follows a standard protocol: 1. Informational responses ( 100 \u2013 199 ) 2. Successful responses ( 200 \u2013 299 ) 3. Redirection messages ( 300 \u2013 399 ) 4. Client error responses ( 400 \u2013 499 ) 5. Server error responses ( 500 \u2013 599 ) Check this link for more details. You can replace x = requests.get(url) by x = requests.post(url) to run a POST request. POST allows attaching additional content to requests. One popular attachment is JSON data, a simple text-based data structure for key-value pairs (and more). So, you may modify the above code to attach content to your request. myobj = {'somekey': 'somevalue'} x = requests.post(url, json = myobj) Web communication in Python - Server side Instead of relying on bash script (which in many cases is useful for simple application), we will use a fully fledged programming language Python. * Create a file <web root>/cgi/test.py . sudo touch <web root>/cgi/test.py Give the the write permission and owner cd <web root>/cgi sudo chown www-data:www-data * sudo chmod 755 * * means all files in Bash. * Now, you may modify to return a JSON response, which is more convenient response for an API (since apps calling the API can easily parse it, unlike html). We want the output to look like HTTP/1.1 200 OK Content-Type: application/json Content-Length: <decided automatically> {\"number\":\"<received number> * 10\"} You may produce this output using bash script with cgi/test.sh , but I'd personally go with a programming language such as Python. Below is an example code, which is self-explanatory #! /usr/bin/python3 import os # Parsing QUERY_STRING q = os.getenv('QUERY_STRING') num_str = q.split('=')[1] num = int(num_str) * 10 # Generating HTTP response with JSON response = \"{\\\"number\\\": \\\"%d\\\"} \"%num print(\"Content-Type: application/json\") print(\"Content-Length: %d\\n\\n\"% len(response)) print(response);","title":"More on RESTful Communication"},{"location":"sys/sys7/#more-on-restful-communication","text":"REST APIs use Uniform Resource Identifiers (URIs) to address resources . REST API designers should create URIs that convey a REST API's resource model to the potential clients of the API. When resources are named well, an API is intuitive and easy to use.","title":"More on RESTful Communication"},{"location":"sys/sys7/#mod-rewrite-with-post-requests","text":"To partition API to POST and GET APIs, you need to modify Apache config to include some conditions. * Open your Apache config file, mine is located in /etc/apache2/sites-available/000-default.conf , and add the following with root permission RewriteCond %{REQUEST_METHOD} ^POST$ [NC] RewriteRule robot cgi/test.sh The condition specifies how to redirect the address based on the request type. Check Apache site for more details about RewriteCond . * Restart your Apache server * To test POST requests, you cannot use your browser easily because the browser operates mainly on GET part of HTTP (unless you create a custom HTML form to submit data). Try curl command ( sudo apt install curl if you don't have it on your system) curl -X POST '<address>/robot' Check if you receive correct HTML response. You can use the same command for GET requests (replacing POST by GET). curl is quite simpler than nc as you don't need to specify HTTP headers. However, it is good to experience low-level interactions, particularly with HTTP protocol, a text-based protocol intended by design to help humans debug easily without sophisticated parsing tools.","title":"Mod Rewrite with POST requests"},{"location":"sys/sys7/#variables","text":"Now, let's use the regex to have a POST URI that takes any number. Replace the RewriteRule by the following: RewriteRule ^robot/([0-9]*\\.?[0-9]*$) cgi/test.sh?data=$1 Let's parse it now: * ^ indicates the beginning of URI, where $ marks the end. So robot/ should be the first sequence of letters. () means a group of letters and is also used as a placeholder for variables in mod_rewrite . [0-9] means any number from 0 to 9, * means the previous character type (or block) is repeated once or multiple times. + means it is repeated 0 or many times. \\ is a skip letter for special characters like . . ? says the previous char or block occurs zero or exactly one time. * Now, test the URI with a POST request curl -X POST '<address>/robot/123.23' The output should be <h1>Hello world from NSR 4.0!</h1> <h2>My name is XXX </h2> <h2> data=123.23 is selected</h2> Try different addresses and see if the regex rule works as intended curl -X POST '<address>/robot/123.23' curl -X POST '<address>/robot/532' curl -X POST '<address>/robot/12a3.23' # Error 404 Not found","title":"Variables"},{"location":"sys/sys7/#web-communication-in-python-client-side","text":"It is quite easy to make HTTP requests in python using libraries like requests . Below is an example code. * Lets make a simple GET request to your previously designed API. Create a file, named req.py (or run interatively using ipython or Jupiter notebook ) import requests url = '<ur server dns>/select/b' x = requests.get(url) print(x.text) If you run print(x) you will get HTTP response status code, which follows a standard protocol: 1. Informational responses ( 100 \u2013 199 ) 2. Successful responses ( 200 \u2013 299 ) 3. Redirection messages ( 300 \u2013 399 ) 4. Client error responses ( 400 \u2013 499 ) 5. Server error responses ( 500 \u2013 599 ) Check this link for more details. You can replace x = requests.get(url) by x = requests.post(url) to run a POST request. POST allows attaching additional content to requests. One popular attachment is JSON data, a simple text-based data structure for key-value pairs (and more). So, you may modify the above code to attach content to your request. myobj = {'somekey': 'somevalue'} x = requests.post(url, json = myobj)","title":"Web communication in Python - Client side"},{"location":"sys/sys7/#web-communication-in-python-server-side","text":"Instead of relying on bash script (which in many cases is useful for simple application), we will use a fully fledged programming language Python. * Create a file <web root>/cgi/test.py . sudo touch <web root>/cgi/test.py Give the the write permission and owner cd <web root>/cgi sudo chown www-data:www-data * sudo chmod 755 * * means all files in Bash. * Now, you may modify to return a JSON response, which is more convenient response for an API (since apps calling the API can easily parse it, unlike html). We want the output to look like HTTP/1.1 200 OK Content-Type: application/json Content-Length: <decided automatically> {\"number\":\"<received number> * 10\"} You may produce this output using bash script with cgi/test.sh , but I'd personally go with a programming language such as Python. Below is an example code, which is self-explanatory #! /usr/bin/python3 import os # Parsing QUERY_STRING q = os.getenv('QUERY_STRING') num_str = q.split('=')[1] num = int(num_str) * 10 # Generating HTTP response with JSON response = \"{\\\"number\\\": \\\"%d\\\"} \"%num print(\"Content-Type: application/json\") print(\"Content-Length: %d\\n\\n\"% len(response)) print(response);","title":"Web communication in Python - Server side"}]}